# 批量转账功能设计方案

## 目录

- [1. 需求概述](#1-需求概述)
- [2. 数据库表设计](#2-数据库表设计)
- [3. 后端API设计](#3-后端api设计)
- [4. 前端UI设计](#4-前端ui设计)
- [5. 业务流程设计](#5-业务流程设计)
- [6. 实时进度反馈机制](#6-实时进度反馈机制)
- [7. 转账失败的重试机制](#7-转账失败的重试机制)
- [8. 查看和恢复进行中的批量任务](#8-查看和恢复进行中的批量任务)
- [9. 防止重复转账机制](#9-防止重复转账机制)
- [10. 安全性考虑](#10-安全性考虑)
- [11. 性能优化](#11-性能优化)
- [12. 实现计划](#12-实现计划)

## 1. 需求概述

批量转账功能分为两大类：
1. **一对多转账**：将一个账户中的余额转移到多个不同的账户中
2. **多对一转账**：将多个账户的余额转移到一个账户中

功能需要支持内部账户和外部账户的操作，并且需要正确处理转账逻辑，参考现有的转账业务。

### 1.1 功能需求

1. **批量创建转账任务**：
   - 支持通过UI界面选择账户和配置转账金额
   - 支持通过Excel/CSV导入批量转账数据
   - 支持保存转账模板，方便重复使用

2. **灵活的转账配置**：
   - 支持均分总金额、固定金额、自定义金额三种模式
   - 支持设置转账备注
   - 支持配置2FA验证方式（自动或手动）

3. **实时进度监控**：
   - 提供实时进度展示
   - 显示成功/失败的转账数量和比例
   - 支持查看详细的转账记录和状态

4. **错误处理和重试**：
   - 提供失败转账的详细错误信息
   - 支持重试单个失败的转账
   - 支持批量重试所有失败的转账

5. **中断和恢复**：
   - 支持中断正在进行的批量转账
   - 支持恢复未完成的批量转账任务

### 1.2 使用场景

1. **薪资发放**：企业需要在固定时间向多个员工账户发放薪资
2. **奖金分配**：将奖金池按照不同比例分配给团队成员
3. **资金归集**：将多个账户的资金归集到一个主账户中
4. **批量退款**：向多个客户同时进行退款操作
5. **定期转账**：按照预设规则定期执行批量转账任务

## 2. 数据库表设计

### 2.1 infini_batch_transfers（批量转账主表）

```sql
CREATE TABLE infini_batch_transfers (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(255) NOT NULL COMMENT '批量转账名称',
  type ENUM('one_to_many', 'many_to_one') NOT NULL COMMENT '转账类型：一对多或多对一',
  status ENUM('pending', 'processing', 'completed', 'failed') NOT NULL DEFAULT 'pending' COMMENT '批量转账状态',
  source VARCHAR(50) NOT NULL COMMENT '来源: batch(批量转账)',
  total_amount VARCHAR(50) NULL COMMENT '总转账金额（字符串格式避免精度问题）',
  success_count INT DEFAULT 0 COMMENT '成功转账数量',
  failed_count INT DEFAULT 0 COMMENT '失败转账数量',
  remarks VARCHAR(500) NULL COMMENT '备注信息',
  created_by VARCHAR(255) NULL COMMENT '创建人',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL,
  completed_at TIMESTAMP NULL COMMENT '完成时间'
);
```

### 2.2 infini_batch_transfer_relations（批量转账关系表）

```sql
CREATE TABLE infini_batch_transfer_relations (
  id INT AUTO_INCREMENT PRIMARY KEY,
  batch_id INT NOT NULL COMMENT '关联的批量转账ID',
  source_account_id INT UNSIGNED NULL COMMENT '源账户ID（多对一时为多个源账户，一对多时为单一源账户）',
  target_account_id INT UNSIGNED NULL COMMENT '目标账户ID（一对多时为多个目标账户，多对一时为单一目标账户）',
  contact_type VARCHAR(20) NULL COMMENT '联系人类型: uid、email或inner',
  target_identifier VARCHAR(255) NULL COMMENT '目标标识符（UID、Email或内部账户ID）',
  amount VARCHAR(50) NOT NULL COMMENT '转账金额（字符串格式避免精度问题）',
  status ENUM('pending', 'processing', 'completed', 'failed') NOT NULL DEFAULT 'pending' COMMENT '转账状态',
  transfer_id INT UNSIGNED NULL COMMENT '关联的单笔转账ID',
  error_message TEXT NULL COMMENT '错误信息',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL,
  FOREIGN KEY (batch_id) REFERENCES infini_batch_transfers(id) ON DELETE CASCADE
);

-- 添加唯一约束，防止在同一批次中对同一账户多次转账
ALTER TABLE infini_batch_transfer_relations 
ADD CONSTRAINT unique_batch_source_target 
UNIQUE (batch_id, source_account_id, target_account_id);
```

### 2.3 infini_batch_transfer_histories（批量转账历史记录表）

```sql
CREATE TABLE infini_batch_transfer_histories (
  id INT AUTO_INCREMENT PRIMARY KEY,
  batch_id INT NOT NULL COMMENT '关联的批量转账ID',
  relation_id INT NULL COMMENT '关联的批量转账关系ID（可选）',
  status VARCHAR(20) NOT NULL COMMENT '状态: pending(准备中), processing(处理中), completed(已完成), failed(失败)',
  message VARCHAR(500) NULL COMMENT '状态描述或消息',
  details TEXT NULL COMMENT '详细信息JSON',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  FOREIGN KEY (batch_id) REFERENCES infini_batch_transfers(id) ON DELETE CASCADE,
  FOREIGN KEY (relation_id) REFERENCES infini_batch_transfer_relations(id) ON DELETE SET NULL
);
## 3. 后端API设计

### 3.1 批量转账控制器（BatchTransferController）

#### 3.1.1 创建批量转账任务

```typescript
// POST /api/batch-transfers
export const createBatchTransfer = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { 
      name,                  // 批量转账名称
      type,                  // 转账类型：one_to_many或many_to_one
      sourceAccountId,       // 源账户ID（一对多模式）
      targetAccountId,       // 目标账户ID（多对一模式）
      relations,             // 转账关系数组
      remarks                // 备注信息
    } = req.body;
    
    // 创建批量转账记录
    // 创建转账关系记录
    // 返回创建结果
  } catch (error) {
    next(error);
  }
};
```

#### 3.1.2 获取批量转账列表

```typescript
// GET /api/batch-transfers
export const getBatchTransfers = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { page = 1, pageSize = 20, status, type } = req.query;
    
    // 查询批量转账记录
    // 返回分页结果
  } catch (error) {
    next(error);
  }
};
```

#### 3.1.3 获取批量转账详情

```typescript
// GET /api/batch-transfers/:id
export const getBatchTransferById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    
    // 查询批量转账记录
    // 查询关联的转账关系
    // 返回详细信息
  } catch (error) {
    next(error);
  }
};
```

#### 3.1.4 执行批量转账

```typescript
// POST /api/batch-transfers/:id/execute
export const executeBatchTransfer = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    const { auto2FA = false } = req.body;
    
    // 更新批量转账状态为processing
    // 异步执行批量转账（可以使用队列或后台任务）
    // 返回执行状态
  } catch (error) {
    next(error);
  }
};
```

#### 3.1.5 获取批量转账历史记录

```typescript
// GET /api/batch-transfers/:id/history
export const getBatchTransferHistory = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    
    // 查询批量转账历史记录
    // 返回历史记录列表
  } catch (error) {
    next(error);
  }
};
```

#### 3.1.6 重试失败的转账

```typescript
// POST /api/batch-transfers/:batchId/relations/:relationId/retry
export const retryTransferRelation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { batchId, relationId } = req.params;
    const { auto2FA } = req.body;
    
    // 查找关系记录
    // 更新状态为pending
    // 异步执行转账
    // 返回执行状态
  } catch (error) {
    next(error);
  }
};
```

#### 3.1.7 批量重试失败的转账

```typescript
// POST /api/batch-transfers/:id/retry-failed
export const retryFailedTransfers = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    const { auto2FA } = req.body;
    
    // 查找所有失败的转账关系
    // 更新状态为pending
    // 异步执行批量转账
    // 返回执行状态
  } catch (error) {
    next(error);
  }
};
```

#### 3.1.8 恢复未完成的批量转账

```typescript
// POST /api/batch-transfers/:id/resume
export const resumeBatchTransfer = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    const { auto2FA } = req.body;
    
    // 查找批量转账记录
    // 查找所有未完成的转账关系
    // 更新状态为pending
    // 异步执行批量转账
    // 返回执行状态
  } catch (error) {
    next(error);
  }
};
```

#### 3.1.9 获取批量转账进度

```typescript
// GET /api/batch-transfers/:id/progress
export const getBatchTransferProgress = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    
    // 查询批量转账记录
    // 查询转账关系统计信息
    // 返回进度信息
  } catch (error) {
    next(error);
  }
};
```

### 3.2 批量转账服务（BatchTransferService）

#### 3.2.1 创建批量转账

```typescript
async createBatchTransfer(data: {
  name: string;
  type: 'one_to_many' | 'many_to_one';
  sourceAccountId?: number;
  targetAccountId?: number;
  relations: Array<{
    sourceAccountId?: number;
    targetAccountId?: number;
    contactType?: 'uid' | 'email' | 'inner';
    targetIdentifier?: string;
    amount: string;
  }>;
  remarks?: string;
}): Promise<ApiResponse>
```

#### 3.2.2 执行批量转账

```typescript
async executeBatchTransfer(batchId: number, auto2FA: boolean = false): Promise<ApiResponse>
```

#### 3.2.3 处理单笔转账

```typescript
private async processTransfer(relation: BatchTransferRelation, auto2FA: boolean = false): Promise<boolean>
```

#### 3.2.4 恢复批量转账

```typescript
async resumeBatchTransfer(batchId: number, auto2FA: boolean = false): Promise<ApiResponse>
```

#### 3.2.5 重试失败的转账

```typescript
async retryTransferRelation(relationId: number, auto2FA: boolean = false): Promise<ApiResponse>
```

#### 3.2.6 批量重试失败的转账

```typescript
async retryFailedTransfers(batchId: number, auto2FA: boolean = false): Promise<ApiResponse>
```
## 4. 前端UI设计

### 4.1 批量转账页面（BatchTransfer）

创建一个新的批量转账页面，参考批量开卡页面的三步流程设计：

#### 4.1.1 步骤1：选择转账模式和账户

- 提供两种模式选择：一对多转账和多对一转账
- 一对多模式：选择一个源账户和多个目标账户
- 多对一模式：选择多个源账户和一个目标账户
- 提供账户筛选功能，支持按余额、邮箱、UID等条件筛选

#### 4.1.2 步骤2：配置转账参数

- 一对多模式：配置每个目标账户的转账金额（支持均分、固定金额、自定义金额）
- 多对一模式：配置每个源账户的转账金额（支持均分、固定金额、自定义金额）
- 设置转账备注
- 配置2FA验证选项（自动验证或手动验证）

#### 4.1.3 步骤3：执行转账

- 显示转账预览，包括总金额、账户数量等信息
- 提供执行按钮
- 显示转账进度和结果
- 支持导出转账结果

### 4.2 UI组件设计

#### 4.2.1 批量转账模式选择

```jsx
<Radio.Group onChange={handleModeChange} value={transferMode}>
  <Radio value="one_to_many">一对多转账</Radio>
  <Radio value="many_to_one">多对一转账</Radio>
</Radio.Group>
```

#### 4.2.2 账户选择组件

```jsx
<Transfer
  dataSource={transferData}
  titles={transferMode === 'one_to_many' ? ['可选目标账户', '已选目标账户'] : ['可选源账户', '已选源账户']}
  targetKeys={targetKeys}
  onChange={handleTransferChange}
  render={item => (
    <AccountItem>
      <div>{item.title}</div>
      <div>{item.description}</div>
    </AccountItem>
  )}
/>
```

#### 4.2.3 金额配置组件

```jsx
<div>
  <Radio.Group onChange={handleAmountTypeChange} value={amountType}>
    <Radio value="equal">均分总金额</Radio>
    <Radio value="fixed">每账户固定金额</Radio>
    <Radio value="custom">自定义每账户金额</Radio>
  </Radio.Group>
  
  {amountType === 'equal' && (
    <InputNumber
      placeholder="输入总金额"
      value={totalAmount}
      onChange={handleTotalAmountChange}
    />
  )}
  
  {amountType === 'fixed' && (
    <InputNumber
      placeholder="输入每账户金额"
      value={fixedAmount}
      onChange={handleFixedAmountChange}
    />
  )}
  
  {amountType === 'custom' && (
    <List
      dataSource={selectedAccounts}
      renderItem={(account, index) => (
        <List.Item>
          <List.Item.Meta
            avatar={<Avatar icon={<UserOutlined />} />}
            title={account.email}
            description={`UID: ${account.uid}`}
          />
          <InputNumber
            placeholder="输入金额"
            value={customAmounts[index]}
            onChange={(value) => handleCustomAmountChange(index, value)}
          />
        </List.Item>
      )}
    />
  )}
</div>
```

#### 4.2.4 转账进度组件

```jsx
<div>
  <Progress
    percent={progressPercent}
    status={processStatus === 'error' ? 'exception' : undefined}
  />
  <div>
    <Text type="secondary">
      总计: {selectedAccounts.length} | 成功: {successCount} | 失败: {failedCount}
    </Text>
  </div>
</div>
```

### 4.3 导航菜单更新

在侧边菜单的"账户资金"下添加"批量转账"选项：

```jsx
{
  key: 'account-ops',
  icon: <SwapOutlined />,
  label: '账户资金',
  children: [
    {
      key: '/account-transfer',
      label: '账户转账',
    },
    {
      key: '/batch-transfer', // 新增
      label: '批量转账',      // 新增
    },
    {
      key: '/account-details',
      label: '账户明细',
    }
  ]
}
```

## 5. 业务流程设计

### 5.1 一对多转账流程

1. 用户选择一对多转账模式
2. 用户选择一个源账户
3. 用户选择多个目标账户
4. 用户配置转账金额（均分、固定或自定义）
5. 用户设置转账备注和2FA选项
6. 系统创建批量转账记录和关系记录
7. 系统依次执行每个转账关系的转账操作
8. 系统更新批量转账状态和结果

### 5.2 多对一转账流程

1. 用户选择多对一转账模式
2. 用户选择多个源账户
3. 用户选择一个目标账户
4. 用户配置转账金额（均分、固定或自定义）
5. 用户设置转账备注和2FA选项
6. 系统创建批量转账记录和关系记录
7. 系统依次执行每个转账关系的转账操作
8. 系统更新批量转账状态和结果

### 5.3 错误处理和重试机制

1. 对于失败的转账，记录详细的错误信息
2. 提供重试功能，允许用户重试失败的转账
3. 支持跳过特定的失败转账，继续执行其他转账
## 6. 实时进度反馈机制

### 6.1 WebSocket实时通知

```typescript
// 后端WebSocket服务
import { Server } from 'socket.io';

// 在批量转账执行过程中发送实时更新
async executeBatchTransfer(batchId: number) {
  // 获取批量转账信息
  const batch = await db('infini_batch_transfers').where('id', batchId).first();
  const relations = await db('infini_batch_transfer_relations').where('batch_id', batchId);
  
  // 更新状态为处理中
  await this.updateBatchStatus(batchId, 'processing');
  
  // 发送初始进度
  io.to(`batch_transfer_${batchId}`).emit('progress_update', {
    batchId,
    status: 'processing',
    progress: 0,
    totalCount: relations.length,
    successCount: 0,
    failedCount: 0
  });
  
  // 处理每个转账关系
  for (let i = 0; i < relations.length; i++) {
    const relation = relations[i];
    try {
      // 执行单笔转账
      const result = await this.processTransfer(relation);
      
      // 更新关系状态
      await this.updateRelationStatus(relation.id, result ? 'completed' : 'failed');
      
      // 更新批量转账进度
      const progress = Math.floor((i + 1) / relations.length * 100);
      const successCount = await db('infini_batch_transfer_relations')
        .where('batch_id', batchId)
        .where('status', 'completed')
        .count('id as count')
        .first()
        .then(result => result.count);
      
      const failedCount = await db('infini_batch_transfer_relations')
        .where('batch_id', batchId)
        .where('status', 'failed')
        .count('id as count')
        .first()
        .then(result => result.count);
      
      // 发送实时进度更新
      io.to(`batch_transfer_${batchId}`).emit('progress_update', {
        batchId,
        status: 'processing',
        progress,
        totalCount: relations.length,
        successCount,
        failedCount,
        currentRelation: {
          id: relation.id,
          status: result ? 'completed' : 'failed',
          sourceAccount: relation.source_account_id,
          targetAccount: relation.target_account_id,
          amount: relation.amount
        }
      });
    } catch (error) {
      // 处理错误...
    }
  }
  
  // 更新最终状态
  const finalStatus = await this.determineFinalStatus(batchId);
  await this.updateBatchStatus(batchId, finalStatus);
  
  // 发送完成通知
  io.to(`batch_transfer_${batchId}`).emit('progress_update', {
    batchId,
    status: finalStatus,
    progress: 100,
    totalCount: relations.length,
    successCount,
    failedCount,
    completedAt: new Date()
  });
}
```

### 6.2 前端实时进度展示

```jsx
// 前端WebSocket连接
import { useEffect, useState } from 'react';
import { io } from 'socket.io-client';

const BatchTransferProgress = ({ batchId }) => {
  const [progress, setProgress] = useState({
    status: 'pending',
    progress: 0,
    totalCount: 0,
    successCount: 0,
    failedCount: 0,
    currentRelation: null
  });
  
  useEffect(() => {
    const socket = io();
    
    // 加入批量转账房间
    socket.emit('join_room', `batch_transfer_${batchId}`);
    
    // 监听进度更新
    socket.on('progress_update', (data) => {
      setProgress(data);
    });
    
    return () => {
      socket.disconnect();
    };
  }, [batchId]);
  
  return (
    <div>
      <Progress 
        percent={progress.progress} 
        status={progress.status === 'failed' ? 'exception' : undefined}
      />
      <div>
        <Text type="secondary">
          总计: {progress.totalCount} | 成功: {progress.successCount} | 失败: {progress.failedCount}
        </Text>
      </div>
      
      {progress.currentRelation && (
        <Alert
          message={`当前处理: ${progress.currentRelation.sourceAccount} -> ${progress.currentRelation.targetAccount}`}
          description={`金额: ${progress.currentRelation.amount} | 状态: ${progress.currentRelation.status}`}
          type={progress.currentRelation.status === 'completed' ? 'success' : 'error'}
        />
      )}
      
      {/* 显示最近处理的转账列表 */}
      <List
        dataSource={recentTransfers}
        renderItem={item => (
          <List.Item>
            <List.Item.Meta
              title={`${item.sourceAccount} -> ${item.targetAccount}`}
              description={`金额: ${item.amount}`}
            />
            <Tag color={item.status === 'completed' ? 'green' : 'red'}>
              {item.status === 'completed' ? '成功' : '失败'}
            </Tag>
          </List.Item>
        )}
      />
    </div>
  );
};
```

### 6.3 轮询机制（备选方案）

如果不使用WebSocket，也可以实现轮询机制：

```jsx
// 前端轮询进度
const [progress, setProgress] = useState({});

useEffect(() => {
  const intervalId = setInterval(async () => {
    const response = await batchTransferApi.getBatchTransferProgress(batchId);
    if (response.success) {
      setProgress(response.data);
      
      // 如果批量转账已完成，停止轮询
      if (['completed', 'failed'].includes(response.data.status)) {
        clearInterval(intervalId);
      }
    }
  }, 2000); // 每2秒轮询一次
  
  return () => clearInterval(intervalId);
}, [batchId]);
```

## 7. 转账失败的重试机制

### 7.1 单笔转账重试

```typescript
// 后端重试API
export const retryTransferRelation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { batchId, relationId } = req.params;
    const { auto2FA } = req.body;
    
    // 查找关系记录
    const relation = await db('infini_batch_transfer_relations')
      .where('id', relationId)
      .where('batch_id', batchId)
      .first();
    
    if (!relation) {
      return res.status(404).json({
        success: false,
        message: '找不到指定的转账关系'
      });
    }
    
    // 只允许重试失败的转账
    if (relation.status !== 'failed') {
      return res.status(400).json({
        success: false,
        message: '只能重试失败的转账'
      });
    }
    
    // 更新状态为pending
    await db('infini_batch_transfer_relations')
      .where('id', relationId)
      .update({
        status: 'pending',
        error_message: null,
        updated_at: new Date()
      });
    
    // 添加历史记录
    await db('infini_batch_transfer_histories').insert({
      batch_id: batchId,
      relation_id: relationId,
      status: 'pending',
      message: '重试转账',
      created_at: new Date()
    });
    
    // 异步执行转账
    const batchTransferService = new BatchTransferService();
    batchTransferService.processTransferRelation(relationId, auto2FA);
    
    res.json({
      success: true,
      message: '转账重试已开始',
      data: { relationId }
    });
  } catch (error) {
    next(error);
  }
};
```

### 7.2 批量重试失败的转账

```typescript
// 后端批量重试API
export const retryFailedTransfers = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { batchId } = req.params;
    const { auto2FA } = req.body;
    
    // 查找所有失败的转账关系
    const failedRelations = await db('infini_batch_transfer_relations')
      .where('batch_id', batchId)
      .where('status', 'failed')
      .select('id');
    
    if (failedRelations.length === 0) {
      return res.json({
        success: true,
        message: '没有失败的转账需要重试',
        data: { count: 0 }
      });
    }
    
    // 更新所有失败的转账状态为pending
    await db('infini_batch_transfer_relations')
      .where('batch_id', batchId)
      .where('status', 'failed')
      .update({
        status: 'pending',
        error_message: null,
        updated_at: new Date()
      });
    
    // 添加历史记录
    await db('infini_batch_transfer_histories').insert({
      batch_id: batchId,
      status: 'processing',
      message: `重试${failedRelations.length}个失败的转账`,
      created_at: new Date()
    });
    
    // 更新批量转账状态为processing
    await db('infini_batch_transfers')
      .where('id', batchId)
      .update({
        status: 'processing',
        updated_at: new Date()
      });
    
    // 异步执行批量转账
    const batchTransferService = new BatchTransferService();
    batchTransferService.resumeBatchTransfer(batchId, auto2FA);
    
    res.json({
      success: true,
      message: '批量重试已开始',
      data: { count: failedRelations.length }
    });
  } catch (error) {
    next(error);
  }
};
```

### 7.3 前端重试界面

```jsx
// 前端重试界面
const BatchTransferRetry = ({ batchId }) => {
  const [failedTransfers, setFailedTransfers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [auto2FA, setAuto2FA] = useState(false);
  
  useEffect(() => {
    fetchFailedTransfers();
  }, [batchId]);
  
  const fetchFailedTransfers = async () => {
    setLoading(true);
    try {
      const response = await batchTransferApi.getFailedTransfers(batchId);
      if (response.success) {
        setFailedTransfers(response.data);
      }
    } catch (error) {
      message.error('获取失败的转账记录失败');
    } finally {
      setLoading(false);
    }
  };
  
  const handleRetryAll = async () => {
    try {
      const response = await batchTransferApi.retryFailedTransfers(batchId, { auto2FA });
      if (response.success) {
        message.success(`开始重试${response.data.count}个失败的转账`);
      }
    } catch (error) {
      message.error('批量重试失败');
    }
  };
  
  const handleRetrySingle = async (relationId) => {
    try {
      const response = await batchTransferApi.retryTransferRelation(batchId, relationId, { auto2FA });
      if (response.success) {
        message.success('开始重试转账');
        // 更新列表
        fetchFailedTransfers();
      }
    } catch (error) {
      message.error('重试转账失败');
    }
  };
  
  return (
    <div>
      <div style={{ marginBottom: 16 }}>
        <Checkbox checked={auto2FA} onChange={(e) => setAuto2FA(e.target.checked)}>
          使用自动2FA验证
        </Checkbox>
        <Button 
          type="primary" 
          onClick={handleRetryAll}
          disabled={failedTransfers.length === 0}
        >
          重试所有失败的转账
        </Button>
      </div>
      
      <List
        loading={loading}
        dataSource={failedTransfers}
        renderItem={item => (
          <List.Item
            actions={[
              <Button onClick={() => handleRetrySingle(item.id)}>重试</Button>
            ]}
          >
            <List.Item.Meta
              title={`${item.sourceAccount} -> ${item.targetAccount}`}
              description={`金额: ${item.amount} | 错误: ${item.errorMessage}`}
            />
          </List.Item>
        )}
      />
    </div>
  );
};
```

## 8. 查看和恢复进行中的批量任务

### 8.1 批量任务列表页面

```jsx
// 批量任务列表页面
const BatchTransferList = () => {
  const [batchTransfers, setBatchTransfers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [pagination, setPagination] = useState({
    current: 1,
    pageSize: 10,
    total: 0
  });
  
  useEffect(() => {
    fetchBatchTransfers();
  }, [pagination.current, pagination.pageSize]);
  
  const fetchBatchTransfers = async () => {
    setLoading(true);
    try {
      const response = await batchTransferApi.getBatchTransfers({
        page: pagination.current,
        pageSize: pagination.pageSize
      });
      
      if (response.success) {
        setBatchTransfers(response.data.batchTransfers);
        setPagination({
          ...pagination,
          total: response.data.pagination.total
        });
      }
    } catch (error) {
      message.error('获取批量转账列表失败');
    } finally {
      setLoading(false);
    }
  };
  
  const handleTableChange = (pagination) => {
    setPagination(pagination);
  };
  
  const handleResume = async (batchId) => {
    try {
      const response = await batchTransferApi.resumeBatchTransfer(batchId);
      if (response.success) {
        message.success('批量转账已恢复');
        fetchBatchTransfers();
      }
    } catch (error) {
      message.error('恢复批量转账失败');
    }
  };
  
  const columns = [
    {
      title: '名称',
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: '类型',
      dataIndex: 'type',
      key: 'type',
      render: (type) => type === 'one_to_many' ? '一对多' : '多对一'
    },
    {
      title: '状态',
      dataIndex: 'status',
      key: 'status',
      render: (status) => {
        const statusMap = {
          'pending': { text: '等待中', color: 'blue' },
          'processing': { text: '处理中', color: 'orange' },
          'completed': { text: '已完成', color: 'green' },
          'failed': { text: '失败', color: 'red' }
        };
        return <Tag color={statusMap[status].color}>{statusMap[status].text}</Tag>;
      }
    },
    {
      title: '总金额',
      dataIndex: 'totalAmount',
      key: 'totalAmount',
    },
    {
      title: '成功/总数',
      key: 'progress',
      render: (_, record) => `${record.successCount}/${record.successCount + record.failedCount}`
    },
    {
      title: '创建时间',
      dataIndex: 'createdAt',
      key: 'createdAt',
    },
    {
      title: '操作',
      key: 'action',
      render: (_, record) => (
        <Space>
          <Button onClick={() => navigate(`/batch-transfer/detail/${record.id}`)}>
            详情
          </Button>
          {record.status === 'processing' && (
            <Button onClick={() => handleResume(record.id)}>
              恢复
            </Button>
          )}
        </Space>
      )
    }
  ];
  
  return (
    <div>
      <Card title="批量转账列表">
        <Table
          loading={loading}
          dataSource={batchTransfers}
          columns={columns}
          pagination={pagination}
          onChange={handleTableChange}
          rowKey="id"
        />
      </Card>
    </div>
  );
};
```

### 8.2 恢复未完成的批量转账

```typescript
// 后端恢复API
export const resumeBatchTransfer = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { batchId } = req.params;
    const { auto2FA } = req.body;
    
    // 查找批量转账记录
    const batch = await db('infini_batch_transfers')
      .where('id', batchId)
      .first();
    
    if (!batch) {
      return res.status(404).json({
        success: false,
        message: '找不到指定的批量转账'
      });
    }
    
    // 只允许恢复pending或processing状态的批量转账
    if (!['pending', 'processing'].includes(batch.status)) {
      return res.status(400).json({
        success: false,
        message: '只能恢复等待中或处理中的批量转账'
      });
    }
    
    // 查找所有未完成的转账关系
    const pendingRelations = await db('infini_batch_transfer_relations')
      .where('batch_id', batchId)
      .whereIn('status', ['pending', 'processing'])
      .select('id');
    
    if (pendingRelations.length === 0) {
      return res.json({
        success: true,
        message: '没有未完成的转账需要恢复',
        data: { count: 0 }
      });
    }
    
    // 更新所有processing状态的转账为pending
    await db('infini_batch_transfer_relations')
      .where('batch_id', batchId)
      .where('status', 'processing')
      .update({
        status: 'pending',
        updated_at: new Date()
      });
    
    // 添加历史记录
    await db('infini_batch_transfer_histories').insert({
      batch_id: batchId,
      status: 'processing',
      message: `恢复${pendingRelations.length}个未完成的转账`,
      created_at: new Date()
    });
    
    // 更新批量转账状态为processing
    await db('infini_batch_transfers')
      .where('id', batchId)
      .update({
        status: 'processing',
        updated_at: new Date()
      });
    
    // 异步执行批量转账
    const batchTransferService = new BatchTransferService();
    batchTransferService.resumeBatchTransfer(batchId, auto2FA);
    
    res.json({
      success: true,
      message: '批量转账已恢复',
      data: { count: pendingRelations.length }
    });
  } catch (error) {
    next(error);
  }
};
```

### 8.3 批量转账服务中的恢复方法

```typescript
// 批量转账服务中的恢复方法
async resumeBatchTransfer(batchId: number, auto2FA: boolean = false): Promise<ApiResponse> {
  try {
    // 查找所有pending状态的转账关系
    const pendingRelations = await db('infini_batch_transfer_relations')
      .where('batch_id', batchId)
      .where('status', 'pending')
      .select('*');
    
    if (pendingRelations.length === 0) {
      // 如果没有pending状态的转账，检查是否所有转账都已完成
      const allCompleted = await this.checkAllRelationsCompleted(batchId);
      
      if (allCompleted) {
        // 更新批量转账状态为completed
        await this.updateBatchStatus(batchId, 'completed');
        
        return {
          success: true,
          message: '所有转账已完成',
          data: { batchId }
        };
      } else {
        // 更新批量转账状态为failed
        await this.updateBatchStatus(batchId, 'failed');
        
        return {
          success: false,
          message: '批量转账失败',
          data: { batchId }
        };
      }
    }
    
    // 更新批量转账状态为processing
    await this.updateBatchStatus(batchId, 'processing');
    
    // 处理每个pending状态的转账关系
    for (const relation of pendingRelations) {
      try {
        // 更新关系状态为processing
        await this.updateRelationStatus(relation.id, 'processing');
        
        // 执行转账
        const result = await this.processTransfer(relation, auto2FA);
        
        // 更新关系状态
        await this.updateRelationStatus(
          relation.id,
          result ? 'completed' : 'failed',
          result ? null : '转账失败'
        );
      } catch (error) {
        // 更新关系状态为failed
        await this.updateRelationStatus(
          relation.id,
          'failed',
          error.message || '转账处理异常'
        );
      }
    }
    
    // 检查是否所有转账都已完成
    const allCompleted = await this.checkAllRelationsCompleted(batchId);
    
    // 更新批量转账状态
    const finalStatus = allCompleted ? 'completed' : 'failed';
    await this.updateBatchStatus(batchId, finalStatus);
    
    return {
      success: allCompleted,
      message: allCompleted ? '批量转账已完成' : '批量转账部分失败',
      data: { batchId }
    };
  } catch (error) {
    console.error('恢复批量转账失败:', error);
    return {
      success: false,
      message: `恢复批量转账失败: ${error.message}`,
      data: { batchId }
    };
  }
}
```

## 11. 性能优化

1. **批处理方式执行转账**：避免单个大事务
   ```typescript
   // 批处理执行转账
   const BATCH_SIZE = 10; // 每批处理的转账数量
   
   for (let i = 0; i < relations.length; i += BATCH_SIZE) {
     const batch = relations.slice(i, i + BATCH_SIZE);
     
     // 并行处理每批转账
     await Promise.all(batch.map(relation => 
       this.processTransfer(relation, auto2FA)
     ));
     
     // 更新进度
     const progress = Math.min(100, Math.floor((i + batch.length) / relations.length * 100));
     // 发送进度更新...
   }
   ```

2. **异步处理机制**：不阻塞用户界面
   ```typescript
   // 使用异步处理
   export const executeBatchTransfer = async (req: Request, res: Response, next: NextFunction) => {
     try {
       const { id } = req.params;
       
       // 立即返回响应，后台继续处理
       res.json({
         success: true,
         message: '批量转账已开始',
         data: { batchId: id }
       });
       
       // 后台异步执行批量转账
       const batchTransferService = new BatchTransferService();
       batchTransferService.executeBatchTransfer(id, req.body.auto2FA)
         .catch(error => {
           console.error('批量转账执行失败:', error);
           // 更新批量转账状态为failed
           db('infini_batch_transfers')
             .where('id', id)
             .update({
               status: 'failed',
               updated_at: new Date()
             })
             .catch(err => console.error('更新批量转账状态失败:', err));
         });
     } catch (error) {
       next(error);
     }
   };
   ```

3. **实时进度反馈**：增强用户体验
   ```typescript
   // 使用WebSocket提供实时进度反馈
   // 见前面的WebSocket实现
   ```

4. **分页处理大量数据**：避免内存溢出
   ```typescript
   // 分页处理大量数据
   const PAGE_SIZE = 100;
   let page = 1;
   let hasMore = true;
   
   while (hasMore) {
     const accounts = await db('infini_accounts')
       .select('*')
       .limit(PAGE_SIZE)
       .offset((page - 1) * PAGE_SIZE);
     
     if (accounts.length === 0) {
       hasMore = false;
       break;
     }
     
     // 处理当前页的数据...
     
     page++;
   }
   ```

5. **缓存优化**：缓存频繁访问的数据
   ```typescript
   // 使用内存缓存
   const accountCache = new Map();
   
   // 获取账户信息，优先从缓存获取
   const getAccountInfo = async (accountId) => {
     // 检查缓存
     if (accountCache.has(accountId)) {
       return accountCache.get(accountId);
     }
     
     // 从数据库获取
     const account = await db('infini_accounts')
       .where('id', accountId)
       .first();
     
     // 更新缓存
     if (account) {
       accountCache.set(accountId, account);
     }
     
     return account;
   };
   ```

## 12. 实现计划

1. **创建数据库迁移文件**：
   - 创建infini_batch_transfers表
   - 创建infini_batch_transfer_relations表
   - 创建infini_batch_transfer_histories表

2. **实现后端API和服务**：
   - 实现BatchTransferController
   - 实现BatchTransferService
   - 添加WebSocket支持

3. **创建前端页面和组件**：
   - 创建BatchTransfer页面
   - 实现三步流程UI
   - 实现实时进度展示
   - 实现重试和恢复功能

4. **更新导航菜单**：
   - 在"账户资金"下添加"批量转账"选项

5. **测试**：
   - 单元测试
   - 集成测试
   - 端到端测试

6. **部署和监控**：
   - 部署新功能
   - 添加监控和告警
   - 收集用户反馈

### 实施时间表

| 阶段 | 任务 | 预计时间 |
|------|------|----------|
| 1 | 数据库设计和迁移 | 1天 |
| 2 | 后端API和服务实现 | 3天 |
| 3 | 前端页面和组件开发 | 4天 |
| 4 | 测试和修复 | 2天 |
| 5 | 部署和监控 | 1天 |
| **总计** | | **11天** |

### 风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 转账失败率高 | 用户体验差 | 完善重试机制，提供详细错误信息 |
| 性能问题 | 系统响应慢 | 实施批处理和异步处理，优化数据库查询 |
| 安全风险 | 资金损失 | 实施金额限制，2FA验证，转账确认 |
| 并发问题 | 数据不一致 | 使用事务和锁机制，防止重复转账 |

### 后续优化方向

1. **批量转账模板**：支持保存和复用批量转账配置
2. **定时批量转账**：支持定时执行批量转账任务
3. **批量转账报表**：提供详细的批量转账统计和报表
4. **智能转账建议**：基于历史数据提供转账建议
5. **批量转账审批流程**：支持多级审批流程，增强安全性
  ];
  
  return (
    <div>
      <Card title="批量转账列表">
        <Table
          loading={loading}
          dataSource={batchTransfers}
          columns={columns}
          pagination={pagination}
          onChange={handleTableChange}
          rowKey="id"
        />
      </Card>
    </div>
  );
};
```

### 8.2 恢复未完成的批量转账

```typescript
// 后端恢复API
export const resumeBatchTransfer = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { batchId } = req.params;
    const { auto2FA } = req.body;
    
    // 查找批量转账记录
    const batch = await db('infini_batch_transfers')
      .where('id', batchId)
      .first();
    
    if (!batch) {
      return res.status(404).json({
        success: false,
        message: '找不到指定的批量转账'
      });
    }
    
    // 只允许恢复pending或processing状态的批量转账
    if (!['pending', 'processing'].includes(batch.status)) {
      return res.status(400).json({
        success: false,
        message: '只能恢复等待中或处理中的批量转账'
      });
    }
    
    // 查找所有未完成的转账关系
    const pendingRelations = await db('infini_batch_transfer_relations')
      .where('batch_id', batchId)
      .whereIn('status', ['pending', 'processing'])
      .select('id');
    
    if (pendingRelations.length === 0) {
      return res.json({
        success: true,
        message: '没有未完成的转账需要恢复',
        data: { count: 0 }
      });
    }
    
    // 更新所有processing状态的转账为pending
    await db('infini_batch_transfer_relations')
      .where('batch_id', batchId)
      .where('status', 'processing')
      .update({
        status: 'pending',
        updated_at: new Date()
      });
    
    // 添加历史记录
    await db('infini_batch_transfer_histories').insert({
      batch_id: batchId,
      status: 'processing',
      message: `恢复${pendingRelations.length}个未完成的转账`,
      created_at: new Date()
    });
    
    // 更新批量转账状态为processing
    await db('infini_batch_transfers')
      .where('id', batchId)
      .update({
        status: 'processing',
        updated_at: new Date()
      });
    
    // 异步执行批量转账
    const batchTransferService = new BatchTransferService();
    batchTransferService.resumeBatchTransfer(batchId, auto2FA);
    
    res.json({
      success: true,
      message: '批量转账已恢复',
      data: { count: pendingRelations.length }
    });
  } catch (error) {
    next(error);
  }
};
```

### 8.3 批量转账服务中的恢复方法

```typescript
// 批量转账服务中的恢复方法
async resumeBatchTransfer(batchId: number, auto2FA: boolean = false): Promise<ApiResponse> {
  try {
    // 查找所有pending状态的转账关系
    const pendingRelations = await db('infini_batch_transfer_relations')
      .where('batch_id', batchId)
      .where('status', 'pending')
      .select('*');
    
    if (pendingRelations.length === 0) {
      // 如果没有pending状态的转账，检查是否所有转账都已完成
      const allCompleted = await this.checkAllRelationsCompleted(batchId);
      
      if (allCompleted) {
        // 更新批量转账状态为completed
        await this.updateBatchStatus(batchId, 'completed');
        
        return {
          success: true,
          message: '所有转账已完成',
          data: { batchId }
        };
      } else {
        // 更新批量转账状态为failed
        await this.updateBatchStatus(batchId, 'failed');
        
        return {
          success: false,
          message: '批量转账失败',
          data: { batchId }
        };
      }
    }
    
    // 更新批量转账状态为processing
    await this.updateBatchStatus(batchId, 'processing');
    
    // 处理每个pending状态的转账关系
    for (const relation of pendingRelations) {
      try {
        // 更新关系状态为processing
        await this.updateRelationStatus(relation.id, 'processing');
        
        // 执行转账
        const result = await this.processTransfer(relation, auto2FA);
        
        // 更新关系状态
        await this.updateRelationStatus(
          relation.id, 
          result ? 'completed' : 'failed',
          result ? null : '转账失败'
        );
      } catch (error) {
        // 更新关系状态为failed
        await this.updateRelationStatus(
          relation.id, 
          'failed', 
          error.message || '转账处理异常'
        );
      }
    }
    
    // 检查是否所有转账都已完成
    const allCompleted = await this.checkAllRelationsCompleted(batchId);
    
    // 更新批量转账状态
    const finalStatus = allCompleted ? 'completed' : 'failed';
    await this.updateBatchStatus(batchId, finalStatus);
    
    return {
      success: allCompleted,
      message: allCompleted ? '批量转账已完成' : '批量转账部分失败',
      data: { batchId }
    };
  } catch (error) {
    console.error('恢复批量转账失败:', error);
    return {
      success: false,
      message: `恢复批量转账失败: ${error.message}`,
      data: { batchId }
    };
  }
}
```

## 9. 防止重复转账机制

### 9.1 创建批量转账时的重复检查

```typescript
// 创建批量转账时的重复检查
async createBatchTransfer(data: BatchTransferCreateData): Promise<ApiResponse> {
  try {
    // 检查重复的目标账户（一对多模式）
    if (data.type === 'one_to_many') {
      const targetIdentifiers = data.relations.map(r => r.targetIdentifier);
      const uniqueTargets = new Set(targetIdentifiers);
      
      if (uniqueTargets.size !== targetIdentifiers.length) {
        return {
          success: false,
          message: '一对多模式下不允许对同一目标账户多次转账',
          data: {
            duplicates: this.findDuplicates(targetIdentifiers)
          }
        };
      }
    }
    
    // 检查重复的源账户（多对一模式）
    if (data.type === 'many_to_one') {
      const sourceAccountIds = data.relations.map(r => r.sourceAccountId);
      const uniqueSources = new Set(sourceAccountIds);
      
      if (uniqueSources.size !== sourceAccountIds.length) {
        return {
          success: false,
          message: '多对一模式下不允许从同一源账户多次转账',
          data: {
            duplicates: this.findDuplicates(sourceAccountIds)
          }
        };
      }
    }
    
    // 继续创建批量转账...
  } catch (error) {
    // 处理错误...
  }
}

// 查找重复项
private findDuplicates(array: any[]): any[] {
  const counts = {};
  const duplicates = [];
  
  for (const item of array) {
    counts[item] = (counts[item] || 0) + 1;
    if (counts[item] > 1 && !duplicates.includes(item)) {
      duplicates.push(item);
    }
  }
  
  return duplicates;
}
```

### 9.2 前端重复检查

```jsx
// 前端重复检查
const validateDuplicates = () => {
  if (transferMode === 'one_to_many') {
    // 检查目标账户是否有重复
    const targetIds = selectedAccounts.map(account => account.id);
    const uniqueTargets = new Set(targetIds);
    
    if (uniqueTargets.size !== targetIds.length) {
      const duplicates = findDuplicates(targetIds);
      const duplicateAccounts = selectedAccounts.filter(account => 
        duplicates.includes(account.id)
      );
      
      message.error(
        `检测到重复的目标账户: ${duplicateAccounts.map(a => a.email).join(', ')}`
      );
      return false;
    }
  } else if (transferMode === 'many_to_one') {
    // 检查源账户是否有重复
    const sourceIds = selectedAccounts.map(account => account.id);
    const uniqueSources = new Set(sourceIds);
    
    if (uniqueSources.size !== sourceIds.length) {
      const duplicates = findDuplicates(sourceIds);
      const duplicateAccounts = selectedAccounts.filter(account => 
        duplicates.includes(account.id)
      );
      
      message.error(
        `检测到重复的源账户: ${duplicateAccounts.map(a => a.email).join(', ')}`
      );
      return false;
    }
  }
  
  return true;
};

// 查找重复项
const findDuplicates = (array) => {
  const counts = {};
  const duplicates = [];
  
  for (const item of array) {
    counts[item] = (counts[item] || 0) + 1;
    if (counts[item] > 1 && !duplicates.includes(item)) {
      duplicates.push(item);
    }
  }
  
  return duplicates;
};
```

## 10. 安全性考虑

1. **转账金额限制**：实现转账金额上限，防止意外的大额转账
   ```typescript
   // 检查转账金额是否超过限制
   const MAX_TRANSFER_AMOUNT = 10000; // 单笔最大转账金额
   const MAX_BATCH_TRANSFER_AMOUNT = 100000; // 批量转账最大总金额
   
   if (parseFloat(amount) > MAX_TRANSFER_AMOUNT) {
     return {
       success: false,
       message: `单笔转账金额不能超过${MAX_TRANSFER_AMOUNT}`
     };
   }
   
   // 检查批量转账总金额
   const totalAmount = relations.reduce((sum, r) => sum + parseFloat(r.amount), 0);
   if (totalAmount > MAX_BATCH_TRANSFER_AMOUNT) {
     return {
       success: false,
       message: `批量转账总金额不能超过${MAX_BATCH_TRANSFER_AMOUNT}`
     };
   }
   ```

2. **转账确认步骤**：要求用户确认转账信息
   ```jsx
   // 转账确认对话框
   Modal.confirm({
     title: '确认批量转账',
     content: (
       <div>
         <p>转账类型: {transferMode === 'one_to_many' ? '一对多' : '多对一'}</p>
         <p>账户数量: {selectedAccounts.length}</p>
         <p>总金额: {totalAmount}</p>
         <p>请确认以上信息无误</p>
       </div>
     ),
     onOk: () => handleExecuteTransfer(),
     okText: '确认转账',
     cancelText: '取消'
   });
   ```

3. **2FA验证**：支持2FA验证，确保转账安全
   ```typescript
   // 检查账户是否开启了2FA
   if (account.google_2fa_is_bound) {
     // 如果未提供验证码且未启用自动2FA，则要求提供验证码
     if (!verificationCode && !auto2FA) {
       return {
         success: false,
         message: '账户已开启2FA，请提供验证码',
         data: { require2FA: true }
       };
     }
     
     // 如果启用了自动2FA，则自动生成验证码
     if (auto2FA) {
       // 使用TotpToolService生成TOTP验证码
       const totpService = new TotpToolService();
       const totpResult = await totpService.generateTotpCode(account.secret_key);
       verificationCode = totpResult.data.code;
     }
   }
   ```

4. **操作日志**：记录详细的操作日志，便于审计和追踪
   ```typescript
   // 记录操作日志
   await db('operation_logs').insert({
     user_id: req.user.id,
     operation_type: 'batch_transfer',
     operation_id: batchId,
     details: JSON.stringify({
       type: data.type,
       sourceAccountId: data.sourceAccountId,
       targetAccountId: data.targetAccountId,
       relationsCount: data.relations.length,
       totalAmount
     }),
     ip_address: req.ip,
     created_at: new Date()
   });
   ```

5. **中断功能**：提供中断功能，允许用户在必要时中断批量转账过程
   ```typescript
   // 后端中断API
   export const cancelBatchTransfer = async (req: Request, res: Response, next: NextFunction) => {
     try {
       const { batchId } = req.params;
       
       // 查找批量转账记录
       const batch = await db('infini_batch_transfers')
         .where('id', batchId)
         .first();
       
       if (!batch) {
         return res.status(404).json({
           success: false,
           message: '找不到指定的批量转账'
         });
       }
       
       // 只允许中断pending或processing状态的批量转账
       if (!['pending', 'processing'].includes(batch.status)) {
         return res.status(400).json({
           success: false,
           message: '只能中断等待中或处理中的批量转账'
         });
       }
       
       // 更新批量转账状态为failed
       await db('infini_batch_transfers')
         .where('id', batchId)
         .update({
           status: 'failed',
           updated_at: new Date()
         });
       
       // 更新所有pending或processing状态的转账关系为failed
       await db('infini_batch_transfer_relations')
         .where('batch_id', batchId)
         .whereIn('status', ['pending', 'processing'])
         .update({
           status: 'failed',
           error_message: '用户手动中断',
           updated_at: new Date()
         });
       
       // 添加历史记录
       await db('infini_batch_transfer_histories').insert({
         batch_id: batchId,
         status: 'failed',
         message: '用户手动中断批量转账',
         created_at: new Date()
       });
       
       res.json({
         success: true,
         message: '批量转账已中断',
         data: { batchId }
       });
     } catch (error) {
       next(error);
     }
   };
   ```
   
   ```jsx
   // 前端中断按钮
   <Button
     type="danger"
     onClick={handleCancelTransfer}
     loading={cancelling}
     disabled={!['pending', 'processing'].includes(batchStatus)}
   >
     中断转账
   </Button>
   
   // 中断处理函数
   const handleCancelTransfer = async () => {
     setCancelling(true);
     try {
       const response = await batchTransferApi.cancelBatchTransfer(batchId);
       if (response.success) {
         message.success('批量转账已中断');
         // 刷新状态
         fetchBatchTransferDetails();
       }
     } catch (error) {
       message.error('中断批量转账失败');
     } finally {
       setCancelling(false);
     }
   };
   ```

## 11. 性能优化

1. **批处理方式执行转账**：避免单个大事务
  ```typescript
  // 批处理执行转账
  const BATCH_SIZE = 10; // 每批处理的转账数量
  
  for (let i = 0; i < relations.length; i += BATCH_SIZE) {
    const batch = relations.slice(i, i + BATCH_SIZE);
    
    // 并行处理每批转账
    await Promise.all(batch.map(relation =>
      this.processTransfer(relation, auto2FA)
    ));
    
    // 更新进度
    const progress = Math.min(100, Math.floor((i + batch.length) / relations.length * 100));
    // 发送进度更新...
  }
  ```

2. **异步处理机制**：不阻塞用户界面
  ```typescript
  // 使用异步处理
  export const executeBatchTransfer = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { id } = req.params;
      
      // 立即返回响应，后台继续处理
      res.json({
        success: true,
        message: '批量转账已开始',
        data: { batchId: id }
      });
      
      // 后台异步执行批量转账
      const batchTransferService = new BatchTransferService();
      batchTransferService.executeBatchTransfer(id, req.body.auto2FA)
        .catch(error => {
          console.error('批量转账执行失败:', error);
          // 更新批量转账状态为failed
          db('infini_batch_transfers')
            .where('id', id)
            .update({
              status: 'failed',
              updated_at: new Date()
            })
            .catch(err => console.error('更新批量转账状态失败:', err));
        });
    } catch (error) {
      next(error);
    }
  };
  ```

3. **实时进度反馈**：增强用户体验
  ```typescript
  // 使用WebSocket提供实时进度反馈
  // 见前面的WebSocket实现
  ```

4. **分页处理大量数据**：避免内存溢出
  ```typescript
  // 分页处理大量数据
  const PAGE_SIZE = 100;
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const accounts = await db('infini_accounts')
      .select('*')
      .limit(PAGE_SIZE)
      .offset((page - 1) * PAGE_SIZE);
    
    if (accounts.length === 0) {
      hasMore = false;
      break;
    }
    
    // 处理当前页的数据...
    
    page++;
  }
  ```

5. **缓存优化**：缓存频繁访问的数据
  ```typescript
  // 使用内存缓存
  const accountCache = new Map();
  
  // 获取账户信息，优先从缓存获取
  const getAccountInfo = async (accountId) => {
    // 检查缓存
    if (accountCache.has(accountId)) {
      return accountCache.get(accountId);
    }
    
    // 从数据库获取
    const account = await db('infini_accounts')
      .where('id', accountId)
      .first();
    
    // 更新缓存
    if (account) {
      accountCache.set(accountId, account);
    }
    
    return account;
  };
  ```

## 12. 实现计划

1. **创建数据库迁移文件**：
  - 创建infini_batch_transfers表
  - 创建infini_batch_transfer_relations表
  - 创建infini_batch_transfer_histories表

2. **实现后端API和服务**：
  - 实现BatchTransferController
  - 实现BatchTransferService
  - 添加WebSocket支持

3. **创建前端页面和组件**：
  - 创建BatchTransfer页面
  - 实现三步流程UI
  - 实现实时进度展示
  - 实现重试和恢复功能

4. **更新导航菜单**：
  - 在"账户资金"下添加"批量转账"选项

5. **测试**：
  - 单元测试
  - 集成测试
  - 端到端测试

6. **部署和监控**：
  - 部署新功能
  - 添加监控和告警
  - 收集用户反馈

### 实施时间表

| 阶段 | 任务 | 预计时间 |
|------|------|----------|
| 1 | 数据库设计和迁移 | 1天 |
| 2 | 后端API和服务实现 | 3天 |
| 3 | 前端页面和组件开发 | 4天 |
| 4 | 测试和修复 | 2天 |
| 5 | 部署和监控 | 1天 |
| **总计** | | **11天** |

### 风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 转账失败率高 | 用户体验差 | 完善重试机制，提供详细错误信息 |
| 性能问题 | 系统响应慢 | 实施批处理和异步处理，优化数据库查询 |
| 安全风险 | 资金损失 | 实施金额限制，2FA验证，转账确认 |
| 并发问题 | 数据不一致 | 使用事务和锁机制，防止重复转账 |

### 后续优化方向

1. **批量转账模板**：支持保存和复用批量转账配置
2. **定时批量转账**：支持定时执行批量转账任务
3. **批量转账报表**：提供详细的批量转账统计和报表
4. **智能转账建议**：基于历史数据提供转账建议
5. **批量转账审批流程**：支持多级审批流程，增强安全性